<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Paint</title>
    <style>
      div.board {
        margin-top: 10px;
        height: 400px;
        width: 800px;
        max-width: 100%;
        border: 1px solid red;
        position: relative;
        overflow: hidden;
        resize: both;
      }
      input[type="radio"],
      input[type="checkbox"] {
        display: none;
      }
      input[type="radio"]:checked + label,
      input[type="checkbox"]:checked + label {
        background-color: #0075ff;
        font-weight: bolder;
        color: white;
        border-color: black;
      }
      input[type="radio"] + label,
      input[type="checkbox"] + label {
        background-color: lightgray;
        color: black;
        display: inline-block;
        width: 30px;
        border: 1px solid;
        border-radius: 5px;
        text-align: center;
      }
      input + label:hover {
        background-color: #005cc8;
        border-color: #000;
        color: white;
        cursor: pointer;
      }
      input[type="color"] {
        width: 20px;
        cursor: pointer;
      }

      /* .hidden {
        display: none;
      } */
    </style>
  </head>

  <body>
    <span>Tool:</span>
    <input type="radio" name="tool" id="tool-brush" checked />
    <label for="tool-brush">&#9998;</label>
    <input type="radio" name="tool" id="tool-ellipse" />
    <label for="tool-ellipse">&#9675;</label>
    <input type="radio" name="tool" id="tool-rect" />
    <label for="tool-rect">&#9645;</label>

    <input type="range" name="stroke-width" id="stroke-width" min="1" max="20" value="5" />
    <label for="stroke-width" id="label-width"></label>

    <input type="checkbox" name="fill" id="fill" />
    <label for="fill">Fill</label>
    <span>Color:</span>
    <input type="color" name="color" id="pen-color" /> /
    <input type="color" name="fillColor" id="fill-color" value="#ffffff" />

    <div class="board">
      <svg
        version="1.1"
        baseProfile="full"
        width="100%"
        height="100%"
        xmlns="http://www.w3.org/2000/svg"
      ></svg>
    </div>

    <button id="clear">Clear All</button>
    <button id="save">Save File</button>

    <p>鼠标左键使用前景色绘制，鼠标右键使用背景色绘制</p>
    <p>点击 Fill 按钮使用 填充模式</p>

    <script>
      let toolBrush = document.querySelector("#tool-brush");
      let toolEllipse = document.querySelector("#tool-ellipse");
      let toolRect = document.querySelector("#tool-rect");
      let fillButton = document.querySelector("#fill");
      let clearButton = document.querySelector("#clear");
      let saveButton = document.querySelector("#save");

      toolBrush.addEventListener("click", () => (tool = "brush"));
      toolEllipse.addEventListener("click", () => (tool = "ellipse"));
      toolRect.addEventListener("click", () => (tool = "rect"));

      let svg = document.querySelector("svg");
      let penColor = document.querySelector("#pen-color");
      let fillColor = document.querySelector("#fill-color");
      let strokeWidth = document.querySelector("#stroke-width");
      let strokeWidthLable = document.querySelector("#label-width");

      let tool = "brush";
      let isFilled = false;
      let startPos;

      // let reduStack = [];

      let observer = new ResizeObserver((entries) => {
        for (let entry of entries) {
          svg.setAttribute("width", entry.contentRect.width);
          svg.setAttribute("height", entry.contentRect.height);
        }
      });
      observer.observe(svg.parentNode);

      strokeWidthLable.textContent = strokeWidth.value;

      strokeWidth.addEventListener("input", function (e) {
        strokeWidthLable.textContent = strokeWidth.value;
      });

      fillButton.addEventListener("click", function (e) {
        if (this.checked) {
          isFilled = true;
        } else {
          isFilled = false;
        }
      });

      function drawLine(e) {
        if (e.buttons == 0) {
          document.removeEventListener("mousemove", drawLine);
        } else {
          let pos = getReletivePos(svg);
          let polyline = svg.lastChild;

          let points = polyline.getAttribute("points");
          points += ` ${pos.x} ${pos.y}`;
          polyline.setAttribute("points", points);
        }
      }

      function drawEllipse(e) {
        if (e.buttons == 0) {
          document.removeEventListener("mousemove", drawEllipse);
        } else {
          let ellipse = svg.lastChild;
          let pos = getReletivePos(svg);

          ellipse.setAttribute("cx", (pos.x + startPos.x) / 2);
          ellipse.setAttribute("cy", (pos.y + startPos.y) / 2);
          ellipse.setAttribute("rx", Math.abs(pos.x - startPos.x) / 2);
          ellipse.setAttribute("ry", Math.abs(pos.y - startPos.y) / 2);
        }
      }

      function drawRect(e) {
        if (e.buttons == 0) {
          document.removeEventListener("mousemove", drawRect);
        } else {
          let rect = svg.lastChild;
          let pos = getReletivePos(svg);

          if (pos.x < startPos.x) {
            rect.setAttribute("x", pos.x);
            rect.setAttribute("width", startPos.x - pos.x);
          } else {
            rect.setAttribute("width", pos.x - startPos.x);
          }
          if (pos.y < startPos.y) {
            rect.setAttribute("y", pos.y);
            rect.setAttribute("height", startPos.y - pos.y);
          } else {
            rect.setAttribute("height", pos.y - startPos.y);
          }
        }
      }

      function reset() {
        document.removeEventListener("mouseup", reset);
        document.removeEventListener("mousemove", drawLine);
        document.removeEventListener("mousemove", drawEllipse);
        document.removeEventListener("mousemove", drawRect);
      }

      svg.addEventListener("mousedown", function (e) {
        let pos = getReletivePos(svg);
        startPos = pos;
        let paintColor;
        let secondColor;
        if (e.button == 0) {
          paintColor = penColor.value;
          secondColor = fillColor.value;
        }
        if (e.button == 2) {
          paintColor = fillColor.value;
          secondColor = penColor.value;
        }
        if (e.button == 0 || e.button == 2) {
          if (tool == "brush") {
            let polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
            polyline.setAttribute("stroke", paintColor);
            polyline.setAttribute("stroke-width", strokeWidth.value);
            polyline.setAttribute("stroke-linecap", "round");
            polyline.setAttribute("stroke-linejoin", "round");
            polyline.setAttribute("fill", "none");

            let points = `${pos.x} ${pos.y}`;
            polyline.setAttribute("points", points);
            svg.append(polyline);
            drawLine(e);

            document.addEventListener("mousemove", drawLine);
            document.addEventListener("mouseup", reset);
            window.addEventListener("blur", reset);
          }
          if (tool == "ellipse") {
            let ellipse = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
            svg.append(ellipse);
            if (isFilled) {
              ellipse.setAttribute("fill", secondColor);
            } else {
              ellipse.setAttribute("fill", "none");
            }
            ellipse.setAttribute("stroke", paintColor);
            ellipse.setAttribute("stroke-width", strokeWidth.value);
            startPos = pos;

            ellipse.setAttribute("cx", pos.x);
            ellipse.setAttribute("cy", pos.x);
            ellipse.setAttribute("rx", 0);
            ellipse.setAttribute("ry", 0);

            document.addEventListener("mousemove", drawEllipse);
            document.addEventListener("mouseup", reset);
            window.addEventListener("blur", reset);
          }
          if (tool == "rect") {
            let rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            svg.append(rect);
            if (isFilled) {
              rect.setAttribute("fill", secondColor);
            } else {
              rect.setAttribute("fill", "none");
            }
            rect.setAttribute("stroke", paintColor);
            rect.setAttribute("stroke-width", strokeWidth.value);
            startPos = pos;

            rect.setAttribute("x", pos.x);
            rect.setAttribute("y", pos.y);
            rect.setAttribute("width", 0);
            rect.setAttribute("height", 0);

            document.addEventListener("mousemove", drawRect);
            document.addEventListener("mouseup", reset);
            window.addEventListener("blur", reset);
          }
        }
      });

      svg.addEventListener("contextmenu", (e) => {
        e.preventDefault();
      });
      // 简单撤销
      document.addEventListener("keydown", function (e) {
        let isMac =
          navigator.platform == "Mac68K" ||
          navigator.platform == "MacPPC" ||
          navigator.platform == "Macintosh" ||
          navigator.platform == "MacIntel";

        let control = isMac ? e.metaKey : e.ctrlKey;

        if (e.code == "KeyZ" && control && !e.shiftKey) {
          if (svg.lastChild) svg.removeChild(svg.lastChild);
        }
      });

      clearButton.addEventListener("click", function () {
        Array.from(svg.children).forEach((child) => svg.removeChild(child));
      });

      saveButton.addEventListener("click", function () {
        let blob = new Blob(
          [
            `<?xml version="1.0"?> <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">`,
            svg.outerHTML,
          ],
          { type: "image/svg+xml" }
        );
        let link = URL.createObjectURL(blob);
        let anchor = document.createElement("a");
        anchor.setAttribute("href", link);
        anchor.download = "untitled";
        anchor.click();
      });

      // 获取鼠标事件发生时鼠标相对元素的位置
      function getReletivePos(node) {
        let rect = node.getBoundingClientRect();
        return {
          x: window.event.clientX - rect.x,
          y: window.event.clientY - rect.y,
        };
      }
    </script>
  </body>
</html>
