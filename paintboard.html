<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Paint</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
      }

      .main-container {
        background-color: lightgrey;
        height: 100%;
        min-width: 410px;
        display: flex;
        flex-flow: column;
        justify-content: center;
      }

      header {
        display: flex;
        align-items: center;
        height: 30px;
        padding: 5px;
      }

      header > * {
        margin-right: 10px;
      }

      header button {
        box-sizing: border-box;
        padding: 0 5px;
        border: 1px solid;
        border-radius: 5px;
        height: 30px;
        line-height: 28px;
        font-size: 14px;
        cursor: pointer;
      }

      header button:hover {
        background-color: #005cc8;
        color: white;
        border-color: black;
      }

      div.board {
        flex: 1;
        display: flex;
        max-width: 100%;
        position: relative;
      }

      aside {
        flex-shrink: 0;
        width: 40px;
        display: flex;
        flex-flow: column;
        align-items: center;
      }

      aside input[type="radio"] {
        display: none;
      }

      aside label {
        box-sizing: border-box;
        height: 30px;
        width: 30px;
        border: 1px solid;
        margin-bottom: 5px;
        border-radius: 5px;
        text-align: center;
        font-size: 20px;
        line-height: 28px;
      }

      aside input[type="radio"]:checked + label {
        background-color: #0075ff;
        font-weight: bolder;
        color: white;
        border-color: black;
      }
      aside input[type="radio"] + label:hover {
        background-color: #005cc8;
        border-color: black;
        color: white;
        cursor: pointer;
      }

      aside input[type="color"] {
        background-color: inherit;
        box-sizing: border-box;
        height: 30px;
        width: 30px;
        border: 1px solid;
        border-radius: 5px;
        margin-bottom: 5px;
      }

      svg {
        background-color: white;
        flex-grow: 1;
        box-sizing: border-box;
        border: 1px solid;
        border-radius: 5px;
      }

      div.message {
        padding-left: 40px;
        width: 100%;
      }
    </style>
  </head>

  <body>
    <div class="main-container">
      <header>
        <button id="save">Save File</button>
        <span>粗细</span>
        <input type="range" name="stroke-width" id="stroke-width" min="1" max="20" value="5" />
        <span id="label-width"></span>
        <label for="fill"><input type="checkbox" name="fill" id="fill" />Fill</label>
        <button id="clear">Clear All</button>
      </header>

      <div class="board">
        <aside class="tools">
          <input type="radio" name="tool" id="tool-brush" checked />
          <label for="tool-brush">&#9998;</label>
          <input type="radio" name="tool" id="tool-ellipse" />
          <label for="tool-ellipse">&#9675;</label>
          <input type="radio" name="tool" id="tool-rect" />
          <label for="tool-rect">&#9645;</label>
          <hr />
          <input type="color" name="color" id="pen-color" />
          <input type="color" name="fillColor" id="fill-color" value="#ffffff" />
        </aside>
        <svg
          version="1.1"
          baseProfile="full"
          width="100%"
          height="100%"
          xmlns="http://www.w3.org/2000/svg"
        ></svg>
      </div>
      <div class="message">
        <p>鼠标左键使用前景色绘制，鼠标右键使用背景色绘制</p>
        <p>点击 Fill 按钮使用 填充模式</p>
      </div>
    </div>

    <script>
      let toolBrush = document.querySelector("#tool-brush");
      let toolEllipse = document.querySelector("#tool-ellipse");
      let toolRect = document.querySelector("#tool-rect");
      let fillButton = document.querySelector("#fill");
      let clearButton = document.querySelector("#clear");
      let saveButton = document.querySelector("#save");

      toolBrush.addEventListener("click", () => (tool = "brush"));
      toolEllipse.addEventListener("click", () => (tool = "ellipse"));
      toolRect.addEventListener("click", () => (tool = "rect"));

      let svg = document.querySelector("svg");
      let penColor = document.querySelector("#pen-color");
      let fillColor = document.querySelector("#fill-color");
      let strokeWidth = document.querySelector("#stroke-width");
      let strokeWidthLable = document.querySelector("#label-width");

      let tool = "brush";
      let isFilled = false;
      let startPos;
      let saved = true;

      // let reduStack = [];

      strokeWidthLable.textContent = strokeWidth.value;

      strokeWidth.addEventListener("input", function (e) {
        strokeWidthLable.textContent = strokeWidth.value;
      });

      fillButton.addEventListener("click", function (e) {
        if (this.checked) {
          isFilled = true;
        } else {
          isFilled = false;
        }
      });

      function drawLine(e) {
        if (e.buttons == 0) {
          document.removeEventListener("mousemove", drawLine);
        } else {
          let pos = getReletivePos(svg);
          let polyline = svg.lastChild;

          let points = polyline.getAttribute("points");
          points += ` ${pos.x} ${pos.y}`;
          polyline.setAttribute("points", points);
        }
      }

      function drawEllipse(e) {
        if (e.buttons == 0) {
          document.removeEventListener("mousemove", drawEllipse);
        } else {
          let ellipse = svg.lastChild;
          let pos = getReletivePos(svg);

          ellipse.setAttribute("cx", (pos.x + startPos.x) / 2);
          ellipse.setAttribute("cy", (pos.y + startPos.y) / 2);
          ellipse.setAttribute("rx", Math.abs(pos.x - startPos.x) / 2);
          ellipse.setAttribute("ry", Math.abs(pos.y - startPos.y) / 2);
        }
      }

      function drawRect(e) {
        if (e.buttons == 0) {
          document.removeEventListener("mousemove", drawRect);
        } else {
          let rect = svg.lastChild;
          let pos = getReletivePos(svg);

          if (pos.x < startPos.x) {
            rect.setAttribute("x", pos.x);
            rect.setAttribute("width", startPos.x - pos.x);
          } else {
            rect.setAttribute("width", pos.x - startPos.x);
          }
          if (pos.y < startPos.y) {
            rect.setAttribute("y", pos.y);
            rect.setAttribute("height", startPos.y - pos.y);
          } else {
            rect.setAttribute("height", pos.y - startPos.y);
          }
        }
      }

      function reset() {
        document.removeEventListener("mouseup", reset);
        document.removeEventListener("mousemove", drawLine);
        document.removeEventListener("mousemove", drawEllipse);
        document.removeEventListener("mousemove", drawRect);
      }

      svg.addEventListener("mousedown", function (e) {
        saved = false;
        let pos = getReletivePos(svg);
        startPos = pos;
        let paintColor;
        let secondColor;
        if (e.button == 0) {
          paintColor = penColor.value;
          secondColor = fillColor.value;
        }
        if (e.button == 2) {
          paintColor = fillColor.value;
          secondColor = penColor.value;
        }
        if (e.button == 0 || e.button == 2) {
          if (tool == "brush") {
            let polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
            polyline.setAttribute("stroke", paintColor);
            polyline.setAttribute("stroke-width", strokeWidth.value);
            polyline.setAttribute("stroke-linecap", "round");
            polyline.setAttribute("stroke-linejoin", "round");
            polyline.setAttribute("fill", "none");

            let points = `${pos.x} ${pos.y}`;
            polyline.setAttribute("points", points);
            svg.append(polyline);
            drawLine(e);

            document.addEventListener("mousemove", drawLine);
            document.addEventListener("mouseup", reset);
            window.addEventListener("blur", reset);
          }
          if (tool == "ellipse") {
            let ellipse = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
            svg.append(ellipse);
            if (isFilled) {
              ellipse.setAttribute("fill", secondColor);
            } else {
              ellipse.setAttribute("fill", "none");
            }
            ellipse.setAttribute("stroke", paintColor);
            ellipse.setAttribute("stroke-width", strokeWidth.value);
            startPos = pos;

            ellipse.setAttribute("cx", pos.x);
            ellipse.setAttribute("cy", pos.x);
            ellipse.setAttribute("rx", 0);
            ellipse.setAttribute("ry", 0);

            document.addEventListener("mousemove", drawEllipse);
            document.addEventListener("mouseup", reset);
            window.addEventListener("blur", reset);
          }
          if (tool == "rect") {
            let rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            svg.append(rect);
            if (isFilled) {
              rect.setAttribute("fill", secondColor);
            } else {
              rect.setAttribute("fill", "none");
            }
            rect.setAttribute("stroke", paintColor);
            rect.setAttribute("stroke-width", strokeWidth.value);
            startPos = pos;

            rect.setAttribute("x", pos.x);
            rect.setAttribute("y", pos.y);
            rect.setAttribute("width", 0);
            rect.setAttribute("height", 0);

            document.addEventListener("mousemove", drawRect);
            document.addEventListener("mouseup", reset);
            window.addEventListener("blur", reset);
          }
        }
      });

      svg.addEventListener("contextmenu", (e) => {
        e.preventDefault();
      });
      // 简单撤销
      document.addEventListener("keydown", function (e) {
        let isMac =
          navigator.platform == "Mac68K" ||
          navigator.platform == "MacPPC" ||
          navigator.platform == "Macintosh" ||
          navigator.platform == "MacIntel";

        let control = isMac ? e.metaKey : e.ctrlKey;

        if (e.code == "KeyZ" && control && !e.shiftKey) {
          if (svg.lastChild) svg.removeChild(svg.lastChild);
        }
      });

      clearButton.addEventListener("click", function () {
        Array.from(svg.children).forEach((child) => svg.removeChild(child));
      });

      saveButton.addEventListener("click", function () {
        let rect = svg.getBoundingClientRect();
        let blob = new Blob(
          [
            `<?xml version="1.0"?> <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">`,
            `<svg version="1.1" baseProfile="full" width="${rect.width}" height="${rect.height}" xmlns="http://www.w3.org/2000/svg" >`,
            svg.innerHTML,
            "</svg>",
          ],
          { type: "image/svg+xml" }
        );
        let link = URL.createObjectURL(blob);
        let anchor = document.createElement("a");
        anchor.setAttribute("href", link);
        anchor.download = "untitled";
        anchor.click();
        saved = true;
      });

      window.addEventListener("beforeunload", function (e) {
        if (!saved) {
          return (e.returnValue = " ");
        }
      });

      // 获取鼠标事件发生时鼠标相对元素的位置
      function getReletivePos(node) {
        let rect = node.getBoundingClientRect();
        return {
          x: window.event.clientX - rect.x,
          y: window.event.clientY - rect.y,
        };
      }
    </script>
  </body>
</html>
